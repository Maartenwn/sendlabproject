var mongoose = require('mongoose');
var express = require('express');
var app = express();
var bodyParser = require('body-parser');
var cors = require('cors');
var swaggerJsdoc = require('swagger-jsdoc');
var swaggerUi = require('swagger-ui-express')
var zonnebootSchema = require('./Schemas/ZonnebootSchema');
var testSchema = require('./Schemas/TestSchema');
var lotusSchema = require('./Schemas/LotusSchema');
var warmptePompSchema = require('./Schemas/WarmtePompSchema');
var weerStationSchema = require('./Schemas/WeerstationSchema');
var deviceSchema = require('./Schemas/DevicesSchema');

const swaggerOptions = {
  swaggerDefinition: {
    info: {
      title: 'Test API',
      version: '1.0.0',
      description: 'Test Express API with autogenerated swagger doc',
    },
  },
  apis: ['api.js', './Schemas/LotusSchema.js', './Schemas/WeerstationSchema.js', './Schemas/WarmtePompSchema.js'],
};

const schemas = {
  'zonneboot': mongoose.model('zonneboot', zonnebootSchema.Zonneboot),
  'test_device': mongoose.model('test_device', testSchema.TestData),
  'lotus': mongoose.model('lotus', lotusSchema.Lotus),
  'warmtepomp': mongoose.model('warmtepomp', warmptePompSchema.WarmtePomp),
  'weerstation': mongoose.model('weerstation', weerStationSchema.Weerstation)
}

const specs = swaggerJsdoc(swaggerOptions);


mongoose.connect('mongodb://172.18.0.2:27017/sendlab', { useNewUrlParser: true });
console.log(mongoose.connection.readyState);


const saveData = function (data) {
  var identifier = data.identifier;
  if (identifier.includes('-')) {
    var identifierSplits = identifier.split('-');
    identifier = identifierSplits[0];
    var deviceNumber = identifierSplits[1];
  }

  data.data["deviceNumber"] = deviceNumber;

  var model = schemas[identifier];
  if (!(model === undefined)) {
    var data = new model(data.data);
    data.save((err, data) => {
      if (err) {
        return err.message;
      }
    });
  } else {
    return ({ "Error": "Schema not found : " + data.identifier });
  }
}

//Gets all the data between 2 time points.
const getHistoricData = function (deviceID, beginDate, endDate) {
  var identifier = deviceID;

  //Numbers because mongo + date + aggregate does not work.
  parsedBeginDate = new Date(beginDate).getTime();
  parsedEndDate = new Date(endDate).getTime();

  if (deviceID.includes('|')) {
    var splits = identifier.split('|');
    identifier = splits[0];
    var deviceNumber = splits[1];
    if (splits.length === 3) {
      var subdoc = splits[2]
    }
  };

  var model = schemas[identifier]

  return new Promise((resolve, reject) => {
    if (!(model === undefined)) {
      if (!(subdoc === undefined)) {
        //Cant use 001 in json..
        deviceNumber = parseInt(deviceNumber, 10);
        var agg = [
          `[
              {"$match": { "$and": [{ "deviceNumber" : ${deviceNumber} },{ "${subdoc}": { "$exists": 1 } } , {"${subdoc}.timestamp" : { "$gte" : ${parsedBeginDate}, "$lte" : ${parsedEndDate} }}] } } ,
              {"$project":{"_id" : 0, "__v" : 0, "${subdoc}._id" : 0}},
              {"$sort":{"${subdoc}.timestamp" : 1}}              
            ]`
        ];
        agg = JSON.parse(agg);
        model.aggregate(agg).allowDiskUse(true).then((data) => {
          data.forEach(x => {
            var timestamp = x[subdoc]["timestamp"];
            x[subdoc]["timestamp"] = new Date(timestamp).toISOString();
          })
          resolve(data)
        });
      }
      else {
        fields = Object.keys(model.schema.tree);
        var agg = historicAggBuilder(fields, beginDate, endDate);
        model.aggregate(agg).allowDiskUse(true).then((data) => {
          fields.forEach(x => {
            if ((["deviceNumber", "timestamp", "_id", "__v", "id"]).indexOf(x) >= 0) { }
            else {
              data[0][x].forEach(y => {
                var timestamp = y[x]["timestamp"];
                y[x]["timestamp"] = new Date(timestamp);
              });
            }
          })
          resolve(data)
        });
      }
    } else resolve(reject);
  });
}

// Gets the latest record from every single field in the collection.
const getCurrentData = function (deviceID) {
  var identifier = deviceID;

  if (deviceID.includes('|')) {
    var splits = identifier.split('|');
    identifier = splits[0];
    var deviceNumber = splits[1];
    if (splits.length === 3) {
      var subdoc = splits[2]
    }
  };

  var model = schemas[identifier]

  return new Promise((resolve, reject) => {
    if (!(model === undefined)) {
      if (!(subdoc === undefined)) {
        //Cant use 001 in json..
        deviceNumber = parseInt(deviceNumber, 10);
        var agg = [
          `[           
            {"$match": { "$and": [{ "deviceNumber" : ${deviceNumber} },{ "${subdoc}": { "$exists": 1 } } ] }},            
            {"$project":{"_id" : 0, "__v" : 0, "${subdoc}._id" : 0}},
            {"$limit" : 1}
          ]`
        ];
        agg = JSON.parse(agg);
        model.aggregate(agg).allowDiskUse(true).then((data) => {
          data.forEach(x => {
            var timestamp = x[subdoc]["timestamp"];
            x[subdoc]["timestamp"] = new Date(timestamp).toISOString();
          })
          resolve(data)
        });
      }
      else {
        var fields = Object.keys(model.schema.tree);
        var agg = aggBuilder(fields);
        model.aggregate(agg).allowDiskUse(true).then((data) => {
          fields.forEach(x => {
            if ((["deviceNumber", "timestamp", "_id", "__v", "id"]).indexOf(x) >= 0) { }
            else {
              try {
                if ((data[0][x] === undefined)) { }
                else {
                  var timestamp = data[0][x]["timestamp"];
                  data[0][x]["timestamp"] = new Date(timestamp);
                }
              } catch (error) {
                console.log(error);
              }
            }
          })
          resolve(data);
        });
      }
    } else resolve(reject);
  });
}

// Should be JSON object from start not string parsed to JSON.
function historicAggBuilder(data, startDate, endDate) {

  startDate = new Date(startDate).getTime();
  endDate = new Date(endDate).getTime();
  var agg = `[`
  agg += `{"$facet" : {`
  fields.forEach(x => {
    if ((["deviceNumber", "timestamp", "_id", "__v", "id"]).indexOf(x) >= 0) { }
    else {
      agg += `"${x}" : [`
      agg += `{ "$match": { "$and": [ { "${x}" : {"$exists" : 1}},{"${x}.timestamp" : { "$gt" : ${startDate}, "$lt" : ${endDate} } } ] } },`
      agg += `{ "$project": { "_id": 0, "__v": 0, "${x}._id" : 0} }`
      agg += `],`
    }
  });

  agg = agg.substring(0, agg.length - 2);

  agg += `]`
  agg += `}}`
  agg += `]`
  agg = JSON.parse(agg);
  return agg;
}

// Should be JSON object from start not string parsed to JSON.
function aggBuilder(data) {
  var agg = `[`
  // agg += `{"$sort" : {"timestamp" : 1}},`
  // agg += `{"$limit" : 4000},`
  agg += `{
  "$facet" : {
    `
  data.forEach(x => {
    if ((["deviceNumber", "timestamp", "_id", "__v", "id"]).indexOf(x) >= 0) { }
    else {
      agg += `"${x}" : [`
      agg += `{ "$match": { "${x}": { "$exists": 1 } } },`
      agg += `{ "$sort": { "${x}.timestamp": 1 } },`
      agg += `{ "$project": { "_id": 0, "__v": 0, "${x}._id" : 0 } },`
      agg += `{ "$group": {`
      agg += `"_id": null,`
      agg += `"lastItem": { "$last": "$$ROOT" }`
      agg += `}}, `
      agg += `{"$project": {`
      agg += `"_id" : "$lastItem.${x}"`
      agg += `}}`
      agg += `],`
    }
  });

  agg = agg.substring(0, agg.length - 1);

  agg += `}}, `
  agg += `{"$project" : {`


  data.forEach(x => {
    if ((["deviceNumber", "timestamp", "_id", "__v", "id"]).indexOf(x) >= 0) { }
    else {
      agg += `"${x}" : { "$arrayElemAt": ["$${x}", 0] },`
    }
  })


  agg = agg.substring(0, agg.length - 1);

  agg += `}}, `
  agg += `{"$project" : {    `


  data.forEach(x => {
    if ((["deviceNumber", "timestamp", "_id", "__v", "id"]).indexOf(x) >= 0) { }
    else {
      agg += `"${x}" : "$${x}._id",`
    }
  })


  agg = agg.substring(0, agg.length - 1);

  agg += `}}, `
  agg += `{"$project" : {    `


  data.forEach(x => {
    if ((["deviceNumber", "timestamp", "_id", "__v", "id"]).indexOf(x) >= 0) { }
    else {
      agg += `"${x}" : { "_id" : 0 },`
    }
  })


  agg = agg.substring(0, agg.length - 1);

  agg += `}}`
  agg += `]`

  agg = JSON.parse(agg);
  return agg;
}

module.exports = {
  saveData,
  getCurrentData,
  getHistoricData
}