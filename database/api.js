var mongoose = require('mongoose');
var express = require('express');
var app = express();
var bodyParser = require('body-parser');
var cors = require('cors');
var swaggerJsdoc = require('swagger-jsdoc');
var swaggerUi = require('swagger-ui-express')
var zonnebootSchema = require('./Schemas/ZonnebootSchema');
var testSchema = require('./Schemas/TestSchema');
var lotusSchema = require('./Schemas/LotusSchema');
var warmptePompSchema = require('./Schemas/WarmtePompSchema');
var weerStationSchema = require('./Schemas/WeerstationSchema');
var deviceSchema = require('./Schemas/DevicesSchema');

const swaggerOptions = {
  swaggerDefinition: {
    info: {
      title: 'Test API',
      version: '1.0.0',
      description: 'Test Express API with autogenerated swagger doc',
    },
  },
  apis: ['api.js', './Schemas/LotusSchema.js', './Schemas/WeerstationSchema.js', './Schemas/WarmtePompSchema.js'],
};

const schemas = {
  'zonneboot': mongoose.model('zonneboot', zonnebootSchema.Zonneboot),
  'test_device': mongoose.model('test_device', testSchema.TestData),
  'lotus': mongoose.model('lotus', lotusSchema.Lotus),
  'warmtepomp': mongoose.model('warmtepomp', warmptePompSchema.WarmtePomp),
  'weerstation': mongoose.model('weerstation', weerStationSchema.Weerstation)
}

const specs = swaggerJsdoc(swaggerOptions);


mongoose.connect('mongodb://172.18.0.2:27017/sendlab', { useNewUrlParser: true });
console.log(mongoose.connection.readyState);


const saveData = function (data) {
  var identifier = data.identifier;
  if (identifier.includes('|')) {
    var identifierSplits = identifier.split('|');
    identifier = identifierSplits[0];
    var deviceNumber = identifierSplits[1];
  }

  data.data["deviceNumber"] = deviceNumber;

  var model = schemas[identifier];
  if (!(model === undefined)) {
    var data = new model(data.data);
    data.save((err, data) => {
      if (err) {
        return err.message;
      }
    });
  } else {
    return ({ "Error": "Schema not found : " + data.identifier });
  }
}

var devicesInDB = [];


function saveDeviceInDatabase(identifier, deviceNumber) {
  var model = mongoose.model('Device', deviceSchema.Devices);
  var query = model.find({}, { '_id': 0, '__v': 0 });
  query.then(data => {

    console.log(devicesInDB)
    var saveData = { "deviceName": identifier, "deviceNumber": deviceNumber }
    if (devicesInDB.some(x => x.deviceName === identifier && x.deviceNumber === parseInt(deviceNumber, 10))) { console.log("found") }
    else {
      devicesInDB.push(saveData);
      new model(saveData).save();
    }
  })
}

const getDevices = function () {
  return devicesInDB;
}

const getHistoricData = function (deviceID, beginDate, endDate) {
  var identifier = deviceID;

  //Numbers because mongo + date + aggregate does not work.
  parsedBeginDate = new Date(beginDate).getTime();
  parsedEndDate = new Date(endDate).getTime();

  if (deviceID.includes('/')) {
    var splits = identifier.split('/');
    identifier = splits[0];
    var subdoc = splits[1];
  };


  if (identifier.includes('|')) {
    var identifierSplits = identifier.split('|');
    identifier = identifierSplits[0];
    var deviceNumber = identifierSplits[1];
  };

  var model = schemas[identifier]

  return new Promise((resolve, reject) => {
    if (!(model === undefined)) {
      if (!(subdoc === undefined)) {
        //Cant use 001 in json..
        deviceNumber = parseInt(deviceNumber, 10);
        var agg = [
          `[
              {"$match": { "$and": [{ "deviceNumber" : ${deviceNumber} },{ "${subdoc}": { "$exists": 1 } } , {"${subdoc}.timestamp" : { "$gte" : ${parsedBeginDate}, "$lte" : ${parsedEndDate} }}] } } ,
              {"$project":{"_id" : 0, "__v" : 0, "${subdoc}._id" : 0}},
              {"$sort":{"${subdoc}.timestamp" : 1}}              
            ]`
        ];
        agg = JSON.parse(agg);
        model.aggregate(agg).allowDiskUse(true).then((data) => {
          data.forEach(x => {
            var timestamp = x[subdoc]["timestamp"];
            x[subdoc]["timestamp"] = new Date(timestamp).toISOString();
          })
          resolve(data)
        });
      }
      else {
        model.aggregate([
          { "$project": { "arrayofkeyvalue": { "$objectToArray": "$$ROOT" } } },
          { "$unwind": "$arrayofkeyvalue" },
          { "$group": { "_id": null, "allkeys": { "$addToSet": "$arrayofkeyvalue.k" } } },
          {
            "$project": {
              "fields": {
                "$filter": {
                  input: "$allkeys",
                  as: "num",
                  cond: {
                    $and: [
                      { "$ne": ["$$num", "__v"] },
                      { "$ne": ["$$num", "_id"] },
                      { "$ne": ["$$num", "timestamp"] }
                    ]
                  }
                }
              }
            }
          }
        ]).then((data) => {
          var agg = historicAggBuilder(data, beginDate, endDate);
          var fields = data[0].fields;
          model.aggregate(agg).allowDiskUse(true).then((data) => {
            fields.forEach(x => {
              if (x === "deviceNumber") { }
              else {
                data[0][x].forEach(y => {
                  var timestamp = y[x]["timestamp"];
                  y[x]["timestamp"] = new Date(timestamp);
                });
              }
            })
            resolve(data)
          });
        });
      }
    } else resolve(reject);
  });
}


const getCurrentData = function (deviceID) {
  var identifier = deviceID;

  if (deviceID.includes('/')) {
    var splits = identifier.split('/');
    identifier = splits[0];
    var subdoc = splits[1];
  };


  if (identifier.includes('|')) {
    var identifierSplits = identifier.split('|');
    identifier = identifierSplits[0];
    var deviceNumber = identifierSplits[1];
  };

  var model = schemas[identifier]

  return new Promise((resolve, reject) => {
    if (!(model === undefined)) {
      if (!(subdoc === undefined)) {
        //Cant use 001 in json..
        deviceNumber = parseInt(deviceNumber, 10);
        var agg = [
          `[
            {"$sort":{"${subdoc}.timestamp" : 1}},
            {"$limit : 4000},
            {"$match": { "$and": [{ "deviceNumber" : ${deviceNumber} },{ "${subdoc}": { "$exists": 1 } } ] }},            
            {"$project":{"_id" : 0, "__v" : 0, "${subdoc}._id" : 0}},
            {"$limit" : 1}
          ]`
        ];
        agg = JSON.parse(agg);
        model.aggregate(agg).allowDiskUse(true).then((data) => {
          data.forEach(x => {
            var timestamp = x[subdoc]["timestamp"];
            x[subdoc]["timestamp"] = new Date(timestamp).toISOString();
          })
          resolve(data)
        });
      }
      else {
        model.aggregate([
          { "$project": { "arrayofkeyvalue": { "$objectToArray": "$$ROOT" } } },
          { "$unwind": "$arrayofkeyvalue" },
          { "$group": { "_id": null, "allkeys": { "$addToSet": "$arrayofkeyvalue.k" } } },
          {
            "$project": {
              "fields": {
                "$filter": {
                  input: "$allkeys",
                  as: "num",
                  cond: {
                    $and: [
                      { "$ne": ["$$num", "__v"] },
                      { "$ne": ["$$num", "_id"] },
                      { "$ne": ["$$num", "timestamp"] }
                    ]
                  }
                }
              }
            }
          }
        ]).then((data) => {
          var agg = aggBuilder(data);
          var fields = data[0].fields;
          model.aggregate(agg).allowDiskUse(true).then((data) => {
            fields.forEach(x => {
              if (x === "deviceNumber") { }
              else {
                try {
                  var timestamp = data[0][x]["timestamp"];
                  data[0][x]["timestamp"] = new Date(timestamp);
                } catch (error) {
                  console.log(error);
                }
              }
            })
            resolve(data);
          });
        });
      }
    } else resolve(reject);
  });
}

// Should be JSON object from start not string parsed to JSON.
function historicAggBuilder(data, startDate, endDate) {

  startDate = new Date(startDate).getTime();
  endDate = new Date(endDate).getTime();
  var agg = `[`
  agg += `{"$facet" : {`
  data[0].fields.forEach(x => {
    if (x === "deviceNumber") { }
    else {
      agg += `"${x}" : [`
      agg += `{ "$match": { "$and": [ { "${x}" : {"$exists" : 1}},{"${x}.timestamp" : { "$gt" : ${startDate}, "$lt" : ${endDate} } } ] } },`
      agg += `{ "$project": { "_id": 0, "__v": 0, "${x}._id" : 0} }`
      agg += `],`
    }
  });

  agg = agg.substring(0, agg.length - 2);

  agg += `]`
  agg += `}}`
  agg += `]`
  
  agg = JSON.parse(agg);

  return agg;
}

// Should be JSON object from start not string parsed to JSON.
function aggBuilder(data) {

  var agg = `[`
  agg += `{"$sort" : {"timestamp" : 1}),`
  agg += `{"$limit" : 4000},`
  agg += `{
  "$facet" : {
    `
  data[0].fields.forEach(x => {
    agg += `"${x}" : [`
    agg += `{ "$match": { "${x}": { "$exists": 1 } } },`
    agg += `{ "$sort": { "${x}.timestamp": 1 } },`
    agg += `{ "$project": { "_id": 0, "__v": 0, "${x}._id" : 0 } },`
    agg += `{ "$group": {`
    agg += `"_id": null,`
    agg += `"lastItem": { "$last": "$$ROOT" }`
    agg += `}}, `
    agg += `{"$project": {`
    agg += `"_id" : "$lastItem.${x}"`
    agg += `}}`
    agg += `],`
  });

  agg = agg.substring(0, agg.length - 1);

  agg += `}}, `
  agg += `{"$project" : {`
  data[0].fields.forEach(x => {
    agg += `"${x}" : { "$arrayElemAt": ["$${x}", 0] },`
  })

  agg = agg.substring(0, agg.length - 1);

  agg += `}}, `
  agg += `{"$project" : {    `
  data[0].fields.forEach(x => {
    agg += `"${x}" : "$${x}._id",`
  })

  agg = agg.substring(0, agg.length - 1);

  agg += `}}, `
  agg += `{"$project" : {    `
  data[0].fields.forEach(x => {
    agg += `"${x}" : { "_id" : 0 },`
  })

  agg = agg.substring(0, agg.length - 1);

  agg += `}}`
  agg += `]`

  agg = JSON.parse(agg);
  return agg;
}

module.exports = {
  saveData,
  getCurrentData,
  getHistoricData
}